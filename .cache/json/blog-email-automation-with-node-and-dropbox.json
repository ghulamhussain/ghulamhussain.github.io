{"data":{"wordpressPost":{"title":"Email automation with Node and Dropbox","content":"<blockquote><p>I choose a lazy person to do a hard job. Because a lazy person will find an easy way to do it. &#8211; Bill Gates</p></blockquote>\n<p>This quote, I feel, describes why I love being a programmer. We are generally lazy yet quite good at solving problems, including our own! Sometimes, this may not involve even writing code, but most of the time you can assume we did ü§ì</p>\n<p>So, my most recent problem: My Mum is required to email an invoice to her client fortnightly, and is fairly computer illiterate. This is handwritten and needs to be scanned as a PDF, and because I‚Äôm not around the house much anymore, my sister scans it for her, but she is too lazy to organise the email, so she adds it to my Dropbox so that, finally, I can email it to the client.</p>\n<p>I hate this entire process&#8230; and receiving &#8220;Have you sent that invoice?&#8221; text messages.</p>\n<h4>The steps involved for me are:</h4>\n<ol>\n<li>Downloading the file from Dropbox</li>\n<li>Logging into Mum&#8217;s email account</li>\n<li>Typing a very generic email to the client</li>\n<li>Attaching downloaded file</li>\n<li>Send the email</li>\n</ol>\n<p><strong>Solution:</strong> AUTOMATE ALL THE THINGS!</p>\n<h2>Javacript/Node to the rescue!</h2>\n<p>Javascript and Node seemed the most appropriate for my solution as I knew I would need to run a server-side application to check my Dropbox regularly to find the file. I am also in the process of trying to become more of a fullstack developer, so I knew this would be a great learning exercise.</p>\n<p>Recently I had completed¬†<a href=\"https://learnnode.com/\" target=\"_blank\" rel=\"noopener\">Wes Bos&#8217; Learn Node</a>¬†course which greatly assisted in the design choices for my final solution. This included but was not limited to: Node, ES6, <a href=\"https://scotch.io/tutorials/javascript-promises-for-dummies\" target=\"_blank\" rel=\"noopener\">Promises</a>, <a href=\"https://github.com/nodemailer/nodemailer\" target=\"_blank\" rel=\"noopener\">Nodemailer</a>, <a href=\"https://github.com/kelektiv/node-cron\" target=\"_blank\" rel=\"noopener\">Node Cron</a>, and shell scripting for continuous deployment (but I will go into this further in my next post &#8211; <a href=\"http://twitter.com/daviddeejjames\" target=\"_blank\" rel=\"noopener\">follow me on Twitter!</a>).</p>\n<p>I won&#8217;t go into too much more detail about specifics of the application as you can just take a look at it <a href=\"https://github.com/daviddeejjames/send-that-invoice\" target=\"_blank\" rel=\"noopener\">here on GitHub</a>. However, I would like to go on further to explain the issues I faced, how I could improve the application, and what utilities made writing this application a joy to create!</p>\n<h2>Promises and the Dropbox API</h2>\n<p>Previously, I had worked with the Dropbox API using PHP to create an <a href=\"https://github.com/daviddeejjames/randophoto\" target=\"_blank\" rel=\"noopener\">application</a> that would randomly pick a set of photos and display them onto a webpage. This was fairly basic and just didn&#8217;t feel right because we were just calling the API with a curl function and I am trying to use less PHP where I can these days.</p>\n<p>When it came round to building the invoice application, I found out that Dropbox had created a <a href=\"https://github.com/dropbox/dropbox-sdk-js\" target=\"_blank\" rel=\"noopener\">Javscript SDK</a> to interact with the API. This was exciting, and even more exciting when I read the documentation to find out that it was promise based! Promises mean that you can easily chain a few API calls to get the data that you require or perform the actions you need to with little to no effort.</p>\n<p>Here is an example of a promise chain to download a file. It assumes you are passing the path of the file, which you can get easily using another API call/promise.</p>\n<pre>const Dropbox = require('dropbox');\r\nconst dbx = new Dropbox({ accessToken: process.env.ACCESS_TOKEN });\r\n\r\nexports.getFile = function (path) {\r\n\r\n  const file = dbx.filesDownload({ path: path })\r\n    .then(function (response) {\r\n      return response;\r\n    })\r\n    .catch(function (error) {\r\n      console.log('Error downloading the file ‚ùé');\r\n      return Promise.reject(error);\r\n    });\r\n\r\n  return file;\r\n};\r\n</pre>\n<p>I can&#8217;t believe it&#8217;s not butter! So simple, much file. üêï</p>\n<p>Just to show you I&#8217;m not bluffing, I created another function that I called once the email was sent. This moves the file in Dropbox to another folder to indicate that this invoice has been sent.</p>\n<pre>exports.archiveFile = function (path, subFolderName) {\r\n  const archivedFile = dbx.filesMove({\r\n    from_path: path,\r\n    to_path: '/sent/' + subFolderName + path,\r\n    allow_shared_folder: true,\r\n    autorename: true,\r\n    allow_ownership_transfer: true\r\n  })\r\n    .then(function (fileMove) {\r\n      console.log('File ' + fileMove.name + ' archived successfully! üó≥');\r\n      return fileMove;\r\n    })\r\n    .catch(function (error) {\r\n      console.log('Error archiving the file üí•');\r\n      return Promise.reject(error);\r\n    });\r\n\r\n  return archivedFile;\r\n};\r\n</pre>\n<p>Here I pass the client name as the <code>subFolderName</code> which means that you get a well organised file path like <code>/sent/client-name/INV0001.PDF</code></p>\n<h3>But what about the Email?</h3>\n<p>Oh right, so before we go archiving the file, we obviously send the email. The creation of this email involves a few small parts but the sending of it is very straightforward.</p>\n<p>As my Mum has multiple clients, the solution needed to incorporate some form of reusability and scalability. I managed this by creating each client as a JSON file that would look something like this:</p>\n<pre>{\r\n  \"name\": \"Recipient\",\r\n  \"email\": \"test@email.com\",\r\n  \"subject\": \"An interesting Email Subject\",\r\n  \"text\": \"Hi John Doe,\\n\\nInvoice attached.\\n\\nKind Regards,\\nJane Doe\",\r\n  \"file-prefix\": \"INV\"\r\n}\r\n</pre>\n<p>This ensured each file to be sent from Dropbox would be mailed out based on its filename prefix, allowing each client to have a different name, email, subject, or text within the email. This also means that if she ever get more clients, it is just a matter of creating new JSON files to also be a part of the automation train. üöÇ</p>\n<p>Using the data above and the calls to the Dropbox API we are able to build our email and send it using <a href=\"https://github.com/nodemailer/nodemailer\" target=\"_blank\" rel=\"noopener\">Nodemailer</a>.</p>\n<p>The code for sending an email through Nodemailer is a function call with a few option parameters (as seen below). These are passed then used in conjunction with a transport function, with most of its config set using environment variables (because you don&#8217;t want people spamming you or knowing your SMTP credentials).</p>\n<p>In this application, I added the file using a binary file stream/buffer which sounds far more complicated than it is or needs to be. In reality, it just means we get the binary version of the file from Dropbox, save it as a variable, pass it to the buffer, and then it becomes a file attachment.</p>\n<pre> ...\r\n\r\n const sendInvoice = attachedFile.searchFilePath(filePrefix)\r\n      .then(function (filePath){\r\n        foundFilePath = filePath;\r\n        const file = attachedFile.getFile(filePath);\r\n        return file;\r\n      })\r\n      .then(function (file) {\r\n        const mailPromise = mail.send({\r\n          email: recipient.email,\r\n          subject: recipient.subject,\r\n          text: recipient.text,\r\n          attachments: {   // binary buffer as an attachment\r\n            filename: file.name,\r\n            content: new Buffer(file.fileBinary, 'binary'),\r\n            encoding: 'binary'\r\n          }\r\n        });\r\n        return mailPromise;\r\n      })\r\n\r\n  ...\r\n</pre>\n<p>Voila! There is the majority of the application in just a few function calls. If <code>mailPromise</code> resolves, then our email will send.</p>\n<p>To test email sending while in development, using a service such as <a href=\"https://mailtrap.io/\" target=\"_blank\" rel=\"noopener\">Mailtrap</a> is a lifesaver as it is free and doesn&#8217;t fill up anyone‚Äôs inboxes üòÜ</p>\n<p>Once I got to production, I changed it over to <a href=\"https://www.mailgun.com/\" target=\"_blank\" rel=\"noopener\">Mailgun</a> as you can send up to 10,000 emails every month for free!</p>\n<h3>Automation ü§ñ</h3>\n<p>So it seems the application covers all your previously mentioned steps&#8230; but what makes it automatic?</p>\n<p>Not much really, just run the function once every hour (or as much as you&#8217;d like) using a <a href=\"https://github.com/kelektiv/node-cron\" target=\"_blank\" rel=\"noopener\">cron</a>. A cron is &#8220;a command to an operating system or server for a job that is to be executed at a specified time&#8221;. In this case, the application checks if there are any files to be sent. If there are, execute the rest of the application; if not, don&#8217;t do anything. As previously mentioned, promise chains make this process a breeze.</p>\n<p>Like everything, there is always room to improve. The cron could be removed by only running the function when a file has been uploaded, and obviously you can&#8217;t just do this with the API but you smart cookies out there would&#8217;ve realised you can do this with the use of webhooks (but that‚Äôs for another time).</p>\n<h2>Conclusion</h2>\n<p>This project was super enjoyable! I learnt a multitude of things from Node to Shell scripting, from Cron jobs to Promises. Little side projects like these really push you forward as a developer. They allow for you to be the perfectionist you want to be and create something to improve your life (and sometimes others‚Äô lives too) in more ways than one.</p>\n","excerpt":"<p>I choose a lazy person to do a hard job. Because a lazy person will find an easy way to do it. &#8211; Bill Gates This quote, I feel, describes why I love being a programmer. We are generally lazy yet quite good at solving problems, including our own! Sometimes, this may not involve even [&hellip;]</p>\n","date":"2018-02-11T11:40:11.000Z"},"site":{"id":"Site","siteMetadata":{"title":null,"subtitle":null}}},"pathContext":{"id":"bcf311a6-3de4-553f-a4f4-e227bf9b487d"}}